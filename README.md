# IQPwn

**tl;dr** This repository implements the algorithms in [this paper TODO](TODO) for forging quantum data to pass the "test of quantumness" from [this paper](https://royalsocietypublishing.org/doi/10.1098/rspa.2008.0443).

---

In [[SB2009]](https://royalsocietypublishing.org/doi/10.1098/rspa.2008.0443), a cryptographic protocol is presented for testing the quantum capabilities of an untrusted party. The authors show that under certain cryptographic assumptions, a prover can only pass the interactive test if they are IQP-capable (roughly, that they can run quantum circuits). The code in this repository breaks those assumptions. In particular, this repository contains an implementation of the algorithms described  [here TODO](TODO) for extracting the protocol's secret key. It also contains timing code to generate the plots in the paper.

## Requirements

 - Julia (tested on version 1.2.0)
 - The following Julia packages:
    - Primes
    - ArgParse 
 - Optional: Python 3 + matplotlib for generating timing plots
 
To install the Julia packages, in Julia run `import Pkg; Pkg.add("<packagename>")`

## Breaking the IQP protocol

The authors of [SB2009] posed an online challenge, where the winner would be the first person to generate samples passing their test of quantumness for a specific instance of an IQP circuit they posted online. The code in this repository does exactly that.

Their code, which can be used to generate test instances of the protocol and also contains their challenge program, is located at [quantumchallenges.wordpress.com](quantumchallenges.wordpress.com). When compiled and run, that code can be used to generate text files containing input data for IQP challenges.

If you have generated such a file (call it `test_program`), you can use the code in this repository in a couple ways.

**To generate samples passing the verification test, run**

``` TODO ```

**Note**: It appears there is an error in their verification code. It counts samples that are *non*-orthogonal to the secret vector, instead of orthogonal to it (despite the fact that their paper asks for orthogonal samples). To generate non-orthogonal samples and get satisfying output from their verification procedure, add the `--non_orth` flag to the command above. TODO

**To output the secret key in base64, run**

`TODO`

For binary output instead of base64, use `-s bin`.

**For all options**, simply run `julia IQPwn.jl --help`.

## Generating timing plots

This repository also contains code to time and characterize the key extraction, and generate the plots in the paper. To generate the timing data, run

```bash
cd benchmark
julia run.jl
```

(if that's taking too long, the number of iterations and problem sizes can be adjusted in `run.jl`).

Now that the data has been generated, the plots can be generated by running the following scripts: 

```bash
python plotcandkeys.py
python plottiming.py
```

Requires `matplotlib`.